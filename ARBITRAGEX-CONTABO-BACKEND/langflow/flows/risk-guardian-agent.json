{
  "name": "Risk Guardian Agent",
  "description": "AI Agent especializado en evaluación de riesgos para operaciones de arbitraje - ArbitrageX Supreme V3.0",
  "version": "3.0.0",
  "methodology": "Ingenio Pichichi S.A. - Disciplinado, Organizado, Metodológico",
  "flow": {
    "nodes": [
      {
        "id": "opportunity_input",
        "type": "WebhookInput",
        "position": { "x": 100, "y": 100 },
        "data": {
          "name": "Opportunity Risk Assessment Input",
          "webhook_url": "/api/langflow/risk-assessment-webhook",
          "expected_fields": [
            "opportunity_id",
            "tokens",
            "dexs",
            "expected_profit_eth",
            "gas_estimate",
            "chain",
            "timestamp"
          ]
        }
      },
      
      {
        "id": "market_data_fetcher",
        "type": "PythonFunction",
        "position": { "x": 300, "y": 100 },
        "data": {
          "name": "Market Data Fetcher",
          "code": "def fetch_market_data(opportunity):\n    \"\"\"\n    Obtiene datos de mercado adicionales para evaluación de riesgo\n    \n    Metodología Ingenio Pichichi S.A.:\n    - Disciplinado: Múltiples fuentes de datos\n    - Organizado: Estructuración consistente\n    - Metodológico: Validación de datos\n    \"\"\"\n    import requests\n    import json\n    from datetime import datetime, timedelta\n    \n    token_a = opportunity['tokens']['token_a']['address']\n    token_b = opportunity['tokens']['token_b']['address']\n    \n    market_data = {\n        'volatility': {},\n        'volume': {},\n        'liquidity': {},\n        'price_history': {},\n        'external_risks': {}\n    }\n    \n    try:\n        # Obtener datos de volatilidad (últimas 24h)\n        coingecko_url = f\"https://api.coingecko.com/api/v3/simple/price\"\n        params = {\n            'ids': f\"{opportunity['tokens']['token_a']['symbol']},{opportunity['tokens']['token_b']['symbol']}\",\n            'vs_currencies': 'usd',\n            'include_24hr_vol': 'true',\n            'include_24hr_change': 'true'\n        }\n        \n        response = requests.get(coingecko_url, params=params, timeout=5)\n        if response.status_code == 200:\n            price_data = response.json()\n            \n            for token_symbol in [opportunity['tokens']['token_a']['symbol'], opportunity['tokens']['token_b']['symbol']]:\n                if token_symbol.lower() in price_data:\n                    token_data = price_data[token_symbol.lower()]\n                    market_data['volatility'][token_symbol] = abs(token_data.get('usd_24h_change', 0)) / 100\n                    market_data['volume'][token_symbol] = token_data.get('usd_24h_vol', 0)\n    \n        # Obtener datos de liquidez de DEXs\n        for dex in opportunity['dexs']:\n            dex_name = dex['name'].lower()\n            \n            # Simular call a API de DEX para obtener liquidez actualizada\n            # En implementación real, usar APIs específicas de cada DEX\n            market_data['liquidity'][dex_name] = {\n                'available_liquidity': float(dex['liquidity_eth']),\n                'utilization_rate': 0.7,  # Placeholder\n                'recent_transactions': 150  # Placeholder\n            }\n    \n        # Verificar si hay alertas de seguridad conocidas\n        market_data['external_risks'] = {\n            'honeypot_detected': False,  # Placeholder - implementar verificación real\n            'flash_loan_attacks_recent': False,\n            'unusual_price_movements': False,\n            'high_mev_activity': False\n        }\n        \n        # Calcular métricas de riesgo derivadas\n        market_data['derived_metrics'] = {\n            'average_volatility': sum(market_data['volatility'].values()) / len(market_data['volatility']) if market_data['volatility'] else 0,\n            'total_volume_24h': sum(market_data['volume'].values()),\n            'liquidity_depth_ratio': sum([liq['available_liquidity'] for liq in market_data['liquidity'].values()]) / float(opportunity['expected_profit_eth']),\n            'market_risk_score': 0.0  # Se calculará en el siguiente paso\n        }\n        \n        market_data['metadata'] = {\n            'fetched_at': datetime.now().isoformat(),\n            'data_sources': ['coingecko', 'dex_apis'],\n            'fetch_latency_ms': 2000  # Placeholder\n        }\n        \n    except Exception as e:\n        market_data['error'] = str(e)\n        market_data['fallback_used'] = True\n    \n    return market_data"
        }
      },
      
      {
        "id": "llm_risk_assessor",
        "type": "ChatOpenAI",
        "position": { "x": 500, "y": 100 },
        "data": {
          "name": "Risk Assessment LLM",
          "model_name": "gpt-4o-mini",
          "temperature": 0.05,
          "max_tokens": 3000,
          "system_message": "Eres un especialista en gestión de riesgos DeFi del equipo ArbitrageX Supreme V3.0, siguiendo la metodología disciplinada del Ingenio Pichichi S.A.\n\nTu objetivo es evaluar exhaustivamente los riesgos asociados con cada oportunidad de arbitraje detectada.\n\nFACTORES DE RIESGO A EVALUAR:\n\n1. RIESGO DE FRONTRUN (0-1):\n   - Visibilidad en mempool\n   - Competencia de MEV bots\n   - Gas price susceptibility\n   - Tiempo de confirmación\n\n2. RIESGO DE SLIPPAGE (0-1):\n   - Profundidad de liquidez\n   - Volatilidad histórica\n   - Impacto de precio esperado\n   - Tamaño de la operación vs liquidez\n\n3. RIESGO DE HONEYPOT (0-1):\n   - Análisis de código del contrato\n   - Historial de transacciones\n   - Patrones sospechosos\n   - Verificación de legitimidad\n\n4. RIESGO DE LIQUIDEZ (0-1):\n   - Disponibilidad actual\n   - Tendencias recientes\n   - Concentración de liquidez\n   - Riesgo de withdrawal\n\n5. RIESGO DE GAS (0-1):\n   - Volatilidad del gas price\n   - Congestión de red\n   - Probabilidad de fallo\n   - Costo vs beneficio\n\n6. RIESGO TEMPORAL (0-1):\n   - Ventana de oportunidad\n   - Decay rate del arbitraje\n   - Competencia esperada\n   - Latencia de ejecución\n\nRESPONDE SIEMPRE en formato JSON:\n{\n  \"opportunity_id\": string,\n  \"risk_assessment\": {\n    \"overall_risk_score\": number (0-1),\n    \"recommendation\": \"execute\" | \"skip\" | \"modify_parameters\" | \"monitor\",\n    \"confidence\": number (0-1)\n  },\n  \"detailed_risks\": {\n    \"frontrun_risk\": {\n      \"score\": number (0-1),\n      \"factors\": string[],\n      \"mitigation_strategies\": string[]\n    },\n    \"slippage_risk\": {\n      \"score\": number (0-1),\n      \"estimated_slippage_percent\": number,\n      \"max_acceptable_slippage\": number,\n      \"factors\": string[]\n    },\n    \"honeypot_risk\": {\n      \"score\": number (0-1),\n      \"is_honeypot_suspected\": boolean,\n      \"suspicious_patterns\": string[],\n      \"verification_results\": string[]\n    },\n    \"liquidity_risk\": {\n      \"score\": number (0-1),\n      \"liquidity_depth_ratio\": number,\n      \"availability_risk\": number,\n      \"concentration_risk\": number\n    },\n    \"gas_risk\": {\n      \"score\": number (0-1),\n      \"current_gas_pressure\": string,\n      \"recommended_gas_price\": string,\n      \"failure_probability\": number\n    },\n    \"temporal_risk\": {\n      \"score\": number (0-1),\n      \"opportunity_decay_rate\": number,\n      \"execution_urgency\": \"low\" | \"medium\" | \"high\" | \"critical\",\n      \"competitive_pressure\": number\n    }\n  },\n  \"risk_mitigations\": {\n    \"mev_protection_recommended\": boolean,\n    \"flash_loan_preferred\": boolean,\n    \"bundle_submission_advised\": boolean,\n    \"gas_price_adjustment\": string,\n    \"slippage_tolerance_adjustment\": number,\n    \"execution_timing_optimization\": string\n  },\n  \"market_conditions\": {\n    \"volatility_environment\": \"low\" | \"medium\" | \"high\" | \"extreme\",\n    \"liquidity_environment\": \"abundant\" | \"normal\" | \"constrained\" | \"critical\",\n    \"competition_level\": \"low\" | \"medium\" | \"high\" | \"extreme\",\n    \"network_congestion\": \"low\" | \"medium\" | \"high\" | \"critical\"\n  },\n  \"reasoning\": {\n    \"key_risk_factors\": string[],\n    \"decision_rationale\": string,\n    \"alternative_strategies\": string[],\n    \"monitoring_points\": string[]\n  },\n  \"performance_metrics\": {\n    \"analysis_depth\": \"basic\" | \"standard\" | \"comprehensive\" | \"exhaustive\",\n    \"data_quality_score\": number (0-1),\n    \"processing_time_ms\": number\n  }\n}"
        }
      },
      
      {
        "id": "risk_score_calculator",
        "type": "PythonFunction",
        "position": { "x": 700, "y": 100 },
        "data": {
          "name": "Risk Score Calculator & Validator",
          "code": "def calculate_and_validate_risk_score(llm_assessment, market_data, opportunity):\n    \"\"\"\n    Calcula score de riesgo final y valida recomendación del LLM\n    \n    Metodología Ingenio Pichichi S.A.:\n    - Disciplinado: Validación matemática rigurosa\n    - Organizado: Ponderación sistemática de factores\n    - Metodológico: Trazabilidad completa de decisiones\n    \"\"\"\n    import json\n    import math\n    from datetime import datetime\n    \n    try:\n        assessment = json.loads(llm_assessment)\n        \n        # Ponderaciones para cada tipo de riesgo\n        risk_weights = {\n            'frontrun_risk': 0.25,      # 25% - Crítico para MEV\n            'slippage_risk': 0.20,      # 20% - Impacto directo en profit\n            'honeypot_risk': 0.15,      # 15% - Pérdida total si presente\n            'liquidity_risk': 0.15,     # 15% - Capacidad de ejecución\n            'gas_risk': 0.15,          # 15% - Costo vs beneficio\n            'temporal_risk': 0.10       # 10% - Urgency factor\n        }\n        \n        # Calcular score ponderado\n        weighted_score = 0\n        risk_breakdown = {}\n        \n        detailed_risks = assessment['detailed_risks']\n        \n        for risk_type, weight in risk_weights.items():\n            if risk_type in detailed_risks:\n                risk_score = detailed_risks[risk_type]['score']\n                weighted_contribution = risk_score * weight\n                weighted_score += weighted_contribution\n                \n                risk_breakdown[risk_type] = {\n                    'score': risk_score,\n                    'weight': weight,\n                    'contribution': weighted_contribution\n                }\n        \n        # Ajustes basados en datos de mercado\n        market_adjustments = 0\n        \n        if 'derived_metrics' in market_data:\n            metrics = market_data['derived_metrics']\n            \n            # Ajuste por volatilidad alta\n            if metrics['average_volatility'] > 0.05:  # >5% volatility\n                volatility_penalty = min(0.1, metrics['average_volatility'] - 0.05)\n                market_adjustments += volatility_penalty\n                risk_breakdown['market_volatility_adjustment'] = volatility_penalty\n            \n            # Ajuste por baja liquidez\n            if metrics['liquidity_depth_ratio'] < 10:  # <10x profit in liquidity\n                liquidity_penalty = min(0.1, (10 - metrics['liquidity_depth_ratio']) / 100)\n                market_adjustments += liquidity_penalty\n                risk_breakdown['market_liquidity_adjustment'] = liquidity_penalty\n        \n        # Score final ajustado\n        final_risk_score = min(1.0, weighted_score + market_adjustments)\n        \n        # Validar recomendación del LLM vs score calculado\n        llm_recommendation = assessment['risk_assessment']['recommendation']\n        calculated_recommendation = 'execute'\n        \n        if final_risk_score > 0.7:\n            calculated_recommendation = 'skip'\n        elif final_risk_score > 0.5:\n            calculated_recommendation = 'modify_parameters'\n        elif final_risk_score > 0.3:\n            calculated_recommendation = 'monitor'\n        \n        # Verificar consistencia\n        recommendation_consistent = llm_recommendation == calculated_recommendation\n        \n        # Determinar recomendación final\n        final_recommendation = llm_recommendation if recommendation_consistent else calculated_recommendation\n        \n        # Calcular confianza en el assessment\n        confidence_factors = [\n            assessment['risk_assessment']['confidence'],\n            1.0 - abs(assessment['risk_assessment']['overall_risk_score'] - final_risk_score),\n            1.0 if recommendation_consistent else 0.7,\n            market_data.get('metadata', {}).get('data_quality_score', 0.8)\n        ]\n        \n        final_confidence = sum(confidence_factors) / len(confidence_factors)\n        \n        # Compilar resultado final\n        result = {\n            'opportunity_id': assessment['opportunity_id'],\n            'risk_analysis': {\n                'final_risk_score': final_risk_score,\n                'llm_risk_score': assessment['risk_assessment']['overall_risk_score'],\n                'calculated_risk_score': weighted_score,\n                'market_adjustments': market_adjustments,\n                'final_recommendation': final_recommendation,\n                'llm_recommendation': llm_recommendation,\n                'recommendation_consistent': recommendation_consistent,\n                'confidence': final_confidence\n            },\n            'risk_breakdown': risk_breakdown,\n            'detailed_assessment': assessment,\n            'execution_guidance': {\n                'proceed_with_execution': final_recommendation == 'execute' and final_confidence > 0.7,\n                'required_modifications': [],\n                'monitoring_required': final_recommendation in ['monitor', 'modify_parameters'],\n                'risk_mitigation_priority': 'high' if final_risk_score > 0.6 else 'medium' if final_risk_score > 0.3 else 'low'\n            },\n            'validation': {\n                'validated_at': datetime.now().isoformat(),\n                'validator_version': '3.0.0',\n                'processing_time_ms': 150,  # Estimated\n                'data_sources_used': ['llm_analysis', 'market_data', 'mathematical_validation']\n            }\n        }\n        \n        # Agregar modificaciones requeridas si aplicable\n        if final_recommendation == 'modify_parameters':\n            modifications = []\n            \n            if detailed_risks.get('slippage_risk', {}).get('score', 0) > 0.5:\n                modifications.append(f\"Increase slippage tolerance to {detailed_risks['slippage_risk'].get('max_acceptable_slippage', 1.0):.1%}\")\n            \n            if detailed_risks.get('gas_risk', {}).get('score', 0) > 0.5:\n                modifications.append(f\"Adjust gas price to {detailed_risks['gas_risk'].get('recommended_gas_price', 'auto')}\")\n            \n            if detailed_risks.get('frontrun_risk', {}).get('score', 0) > 0.6:\n                modifications.append(\"Enable MEV protection and bundle submission\")\n            \n            result['execution_guidance']['required_modifications'] = modifications\n        \n        return result\n        \n    except Exception as e:\n        return {\n            'error': f'Risk calculation failed: {str(e)}',\n            'opportunity_id': opportunity.get('opportunity_id', 'unknown'),\n            'risk_analysis': {\n                'final_risk_score': 1.0,  # Max risk on error\n                'final_recommendation': 'skip',\n                'confidence': 0.0\n            },\n            'execution_guidance': {\n                'proceed_with_execution': False,\n                'risk_mitigation_priority': 'critical'\n            }\n        }"
        }
      },\n      \n      {\n        \"id\": \"webhook_output_assessment\",\n        \"type\": \"WebhookOutput\",\n        \"position\": { \"x\": 900, \"y\": 100 },\n        \"data\": {\n          \"name\": \"Risk Assessment Output\",\n          \"webhook_url\": \"/api/temporal/risk-assessment-complete\",\n          \"method\": \"POST\",\n          \"headers\": {\n            \"Content-Type\": \"application/json\",\n            \"X-Agent-Source\": \"risk-guardian\",\n            \"X-Agent-Version\": \"3.0.0\",\n            \"X-Assessment-Type\": \"comprehensive\"\n          }\n        }\n      },\n      \n      {\n        \"id\": \"metrics_collector\",\n        \"type\": \"PythonFunction\",\n        \"position\": { \"x\": 700, \"y\": 250 },\n        \"data\": {\n          \"name\": \"Risk Agent Metrics\",\n          \"code\": \"def collect_risk_agent_metrics(assessment_result, processing_start_time):\\n    \\\"\\\"\\\"\\n    Recopila métricas específicas del agente de riesgo\\n    \\\"\\\"\\\"\\n    import time\\n    from datetime import datetime\\n    \\n    processing_time = time.time() - processing_start_time\\n    \\n    metrics = {\\n        'agent_id': 'risk-guardian',\\n        'timestamp': datetime.now().isoformat(),\\n        'processing_time_ms': int(processing_time * 1000),\\n        'assessment_completed': 'risk_analysis' in assessment_result,\\n        'final_risk_score': assessment_result.get('risk_analysis', {}).get('final_risk_score', 1.0),\\n        'recommendation': assessment_result.get('risk_analysis', {}).get('final_recommendation', 'skip'),\\n        'confidence': assessment_result.get('risk_analysis', {}).get('confidence', 0.0),\\n        'recommendation_consistent': assessment_result.get('risk_analysis', {}).get('recommendation_consistent', False),\\n        'performance': {\\n            'target_latency_ms': 8000,  # 8s target for risk assessment\\n            'actual_latency_ms': int(processing_time * 1000),\\n            'within_target': processing_time < 8.0,\\n            'assessment_quality': 'comprehensive' if processing_time > 5.0 else 'standard'\\n        },\\n        'risk_factors_analyzed': [\\n            'frontrun_risk', 'slippage_risk', 'honeypot_risk',\\n            'liquidity_risk', 'gas_risk', 'temporal_risk'\\n        ]\\n    }\\n    \\n    return metrics\"\n        }\n      }\n    ],\n    \n    \"edges\": [\n      {\n        \"source\": \"opportunity_input\",\n        \"target\": \"market_data_fetcher\",\n        \"source_handle\": \"output\",\n        \"target_handle\": \"opportunity\"\n      },\n      {\n        \"source\": \"opportunity_input\",\n        \"target\": \"llm_risk_assessor\",\n        \"source_handle\": \"output\",\n        \"target_handle\": \"opportunity_data\"\n      },\n      {\n        \"source\": \"market_data_fetcher\",\n        \"target\": \"llm_risk_assessor\",\n        \"source_handle\": \"output\",\n        \"target_handle\": \"market_data\"\n      },\n      {\n        \"source\": \"llm_risk_assessor\",\n        \"target\": \"risk_score_calculator\",\n        \"source_handle\": \"output\",\n        \"target_handle\": \"llm_assessment\"\n      },\n      {\n        \"source\": \"market_data_fetcher\",\n        \"target\": \"risk_score_calculator\",\n        \"source_handle\": \"output\",\n        \"target_handle\": \"market_data\"\n      },\n      {\n        \"source\": \"opportunity_input\",\n        \"target\": \"risk_score_calculator\",\n        \"source_handle\": \"output\",\n        \"target_handle\": \"opportunity\"\n      },\n      {\n        \"source\": \"risk_score_calculator\",\n        \"target\": \"webhook_output_assessment\",\n        \"source_handle\": \"output\",\n        \"target_handle\": \"input\"\n      },\n      {\n        \"source\": \"risk_score_calculator\",\n        \"target\": \"metrics_collector\",\n        \"source_handle\": \"output\",\n        \"target_handle\": \"assessment_result\"\n      }\n    ]\n  },\n  \n  \"configuration\": {\n    \"environment_variables\": {\n      \"OPENAI_API_KEY\": \"${OPENAI_API_KEY}\",\n      \"COINGECKO_API_KEY\": \"${COINGECKO_API_KEY}\",\n      \"TEMPORAL_SERVER_URL\": \"temporal-server:7233\",\n      \"MONITORING_WEBHOOK_URL\": \"http://api-gateway:3007/api/monitoring\",\n      \"AGENT_VERSION\": \"3.0.0\",\n      \"AGENT_NAME\": \"risk-guardian\"\n    },\n    \n    \"risk_thresholds\": {\n      \"max_acceptable_risk\": 0.7,\n      \"modify_parameters_threshold\": 0.5,\n      \"monitor_threshold\": 0.3,\n      \"min_confidence_required\": 0.7,\n      \"max_processing_time_ms\": 8000\n    },\n    \n    \"risk_weights\": {\n      \"frontrun_risk\": 0.25,\n      \"slippage_risk\": 0.20,\n      \"honeypot_risk\": 0.15,\n      \"liquidity_risk\": 0.15,\n      \"gas_risk\": 0.15,\n      \"temporal_risk\": 0.10\n    },\n    \n    \"monitoring\": {\n      \"metrics_enabled\": true,\n      \"detailed_logging\": true,\n      \"prometheus_metrics\": true,\n      \"risk_assessment_alerts\": true,\n      \"webhook_notifications\": true\n    }\n  },\n  \n  \"deployment\": {\n    \"docker_image\": \"langflowai/langflow:1.0.14\",\n    \"resources\": {\n      \"cpu_limit\": \"1500m\",\n      \"memory_limit\": \"3Gi\",\n      \"cpu_request\": \"750m\",\n      \"memory_request\": \"1.5Gi\"\n    },\n    \"scaling\": {\n      \"min_replicas\": 1,\n      \"max_replicas\": 2,\n      \"target_cpu_utilization\": 70\n    }\n  }\n}"